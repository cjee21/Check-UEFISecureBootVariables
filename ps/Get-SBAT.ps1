# Created by github.com/cjee21
# Adapted from code generated by Google Gemini
# License: MIT

function Get-SBAT {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateScript({Test-Path $_ -PathType Leaf})]
        [string]$FilePath
    )

    function Goto {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.FileStream]$FileStream,
            [Parameter(Mandatory=$true)]
            [Int64]$FileOffset
        )
        [void]$FileStream.Seek($FileOffset, [System.IO.SeekOrigin]::Begin)
    }

    function Get_L2 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt16()
    }

    function Get_L4 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt32()
    }

    try {
        # Open the file stream for reading
        $fs = [System.IO.FileStream]::new($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read)
        $br = [System.IO.BinaryReader]::new($fs)

        # Check that it is a MZ/PE
        Goto $fs 0x0
        $MzSig = Get_L2 $br
        if ($MzSig -ne 0x5A4D) {
            throw "Not a MZ/PE"
        }

        # Get the PE Header offset (e_lfanew) from offset 0x3C
        Goto $fs 0x3C 
        $PeOffset = Get_L4 $br

        # Check that we have PE header
        Goto $fs $PeOffset
        $PeSig = Get_L4 $br
        if ($PeSig -ne 0x00004550) {
            throw "Not a PE"
        }

        # Get first 1KB of file
        $BufferSize = 1KB
        $Buffer = New-Object byte[] $BufferSize
        Goto $fs 0x0
        $BytesRead = $fs.Read($Buffer, 0, $BufferSize)
        $FileBytes = $Buffer[0..($BytesRead - 1)]

        # Find .sbat
        [byte[]]$Search = 0x2E, 0x73, 0x62, 0x61, 0x74, 0x00, 0x00, 0x00
        $BytesLength = $FileBytes.Length
        $SearchLength = $Search.Length
        $sbat_section_offset = 0

        # Loop through the source array up to the point where a full match is possible
        for ($Index = 0; $Index -le ($BytesLength - $SearchLength); $Index++) {
            $Match = $true
            # Compare the segment of the source array with the search pattern
            for ($i = 0; $i -lt $SearchLength; $i++) {
                if ($FileBytes[$Index + $i] -ne $Search[$i]) {
                    $Match = $false
                    break # Sequence mismatch, move to the next starting position
                }
            }

            # If $Match is still $true, we found the sequence
            if ($Match) {
                $sbat_section_offset = $Index
            }
        }

        # If no .sbat section
        if ($sbat_section_offset -eq 0) {
            throw ".sbat section not found"
        }

        # Get SBAT offset
        Goto $fs ($sbat_section_offset + 8)
        $SBAT_length = Get_L4 $br
        Goto $fs ($sbat_section_offset + 8 + 4 + 4 + 4)
        $SBAT_offset = Get_L4 $br

        # Get SBAT string
        Goto $fs $SBAT_offset
        $buffer = [byte[]]::new($SBAT_length)
        $bytesRead = $fs.Read($buffer, 0, $SBAT_length)
        if ($bytesRead -gt 0) {
            # Decode the bytes into a UTF-8 string
            # Note: We only decode the bytes that were actually read ($bytesRead)
            return [System.Text.Encoding]::UTF8.GetString($buffer, 0, $bytesRead)
        }
        return "" # Return empty string if 0 bytes were read
    }
    catch {
        Write-Error "Error processing file '$FilePath': $($_.Exception.Message)"
    }
    finally {
        # Always close the streams
        if ($br) { $br.Dispose() }
        if ($fs) { $fs.Dispose() }
    }
}
