# Created by github.com/cjee21
# Adapted from code generated by Google Gemini
# License: MIT

function Get-SBAT {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateScript({Test-Path $_ -PathType Leaf})]
        [string]$FilePath
    )

    function Goto {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.FileStream]$FileStream,
            [Parameter(Mandatory=$true)]
            [Int64]$FileOffset
        )
        [void]$FileStream.Seek($FileOffset, [System.IO.SeekOrigin]::Begin)
    }

    function Get_L2 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt16()
    }

    function Get_L4 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt32()
    }

    function Get_L8 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt64()
    }

    try {
        # Open the file stream for reading
        $fs = [System.IO.FileStream]::new($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read)
        $br = [System.IO.BinaryReader]::new($fs)

        # Check that it is a MZ/PE
        Goto $fs 0x0
        $MzSig = Get_L2 $br
        if ($MzSig -ne 0x5A4D) {
            throw "Not a MZ/PE"
        }

        # Get the PE Header offset (e_lfanew) from offset 0x3C
        Goto $fs 0x3C 
        $PeOffset = Get_L4 $br

        # Check that we have PE header
        Goto $fs $PeOffset
        $PeSig = Get_L4 $br
        if ($PeSig -ne 0x00004550) {
            throw "Not a PE"
        }

        # Get Optional Header magic
        Goto $fs ($PeOffset + 24)
        $OptMagic = Get_L2 $br
        if ($OptMagic -ne 0x10B -and $OptMagic -ne 0x20B) {
            throw "Unsupported Optional Header"
        }

        # Get offset of section headers
        if ($OptMagic -eq 0x10B) {
            $NumRVAandSizesOffset = $PeOffset + 24 + 72 + 16 + 4
        }
        if ($OptMagic -eq 0x20B) {
            $NumRVAandSizesOffset = $PeOffset + 24 + 72 + 32 + 4
        }
        Goto $fs $NumRVAandSizesOffset
        $NumRVAandSizes = Get_L4 $br
        $SectHeadOffset = $NumRVAandSizesOffset + 4 + ($NumRVAandSizes * 8)

        # Find .sbat
        Goto $fs ($PeOffset + 4 + 2)
        $NumSections = Get_L2 $br
        Goto $fs $SectHeadOffset
        $sbat_sectionhead_offset = 0
        for ($Index = 0; $Index -lt $NumSections; $Index++) {
            $SectName = Get_L8 $br
            if ($SectName -eq 0x000000746162732E) {
                $sbat_sectionhead_offset = $SectHeadOffset + ($Index * 40)
            } else {
                Goto $fs ($SectHeadOffset + (($Index + 1) * 40))
            }
        }

        # If no .sbat section
        if ($sbat_sectionhead_offset -eq 0) {
            throw ".sbat section not found"
        }

        # Get SBAT offset and length
        Goto $fs ($sbat_sectionhead_offset + 8)
        $SBAT_length = Get_L4 $br
        Goto $fs ($sbat_sectionhead_offset + 8 + 4 + 4 + 4)
        $SBAT_offset = Get_L4 $br

        # Get SBAT string
        Goto $fs $SBAT_offset
        $buffer = [byte[]]::new($SBAT_length)
        $bytesRead = $fs.Read($buffer, 0, $SBAT_length)
        if ($bytesRead -gt 0) {
            # Decode the bytes into a UTF-8 string
            # Note: We only decode the bytes that were actually read ($bytesRead)
            return [System.Text.Encoding]::UTF8.GetString($buffer, 0, $bytesRead)
        }
        return "" # Return empty string if 0 bytes were read
    }
    catch {
        Write-Error "Error processing file '$FilePath': $($_.Exception.Message)"
    }
    finally {
        # Always close the streams
        if ($br) { $br.Dispose() }
        if ($fs) { $fs.Dispose() }
    }
}
