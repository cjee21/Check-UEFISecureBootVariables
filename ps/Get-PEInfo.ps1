# Created by github.com/cjee21
# Adapted from code generated by Google Gemini
# License: MIT

function Get-PEInfo {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateScript({Test-Path $_ -PathType Leaf})]
        [string]$FilePath
    )

    # Dictionary to translate the numeric Machine value
    $MachineMap = @{
        [UInt16]0x014C = "x86"
        [UInt16]0x01C0 = "ARM"
        [UInt16]0x01C2 = "ARM Thumb"
        [UInt16]0x01C4 = "ARM Thumb-2"
        [UInt16]0x0EBC = "EFI"
        [UInt16]0x8664 = "x64"
        [UInt16]0xAA64 = "ARM64"
    }

    # Dictionary to translate the numeric Subsystem value
    $SubsystemMap = @{
        [UInt16]1 = "Native"
        [UInt16]2 = "Windows GUI"
        [UInt16]3 = "Windows CUI"
        [UInt16]8 = "Native Windows"
        [UInt16]9 = "Windows CE GUI"
        [UInt16]10 = "EFI Application"
        [UInt16]11 = "EFI Boot Service Driver"
        [UInt16]12 = "EFI Runtime Driver"
        [UInt16]13 = "EFI ROM"
        [UInt16]14 = "XBOX"
        [UInt16]16 = "Windows Boot Application"
    }

    function Goto {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.FileStream]$FileStream,
            [Parameter(Mandatory=$true)]
            [Int64]$FileOffset
        )
        [void]$FileStream.Seek($FileOffset, [System.IO.SeekOrigin]::Begin)
    }

    function Get_L2 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt16()
    }

    function Get_L4 {
        param(
            [Parameter(Mandatory=$true)]
            [System.IO.BinaryReader]$BinaryReader
        )
        $BinaryReader.ReadUInt32()
    }

    try {
        # Open the file stream for reading
        $fs = [System.IO.FileStream]::new($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read)
        $br = [System.IO.BinaryReader]::new($fs)

        # Check that it is a MZ/PE
        Goto $fs 0x0
        $MzSig = Get_L2 $br
        if ($MzSig -ne 0x5A4D) {
            throw "Not a MZ/PE"
        }

        # Get the PE Header offset (e_lfanew) from offset 0x3C
        Goto $fs 0x3C 
        $PeOffset = Get_L4 $br

        # Check that we have PE header
        Goto $fs $PeOffset
        $PeSig = Get_L4 $br
        if ($PeSig -ne 0x00004550) {
            throw "Not a PE"
        }

        # Get Machine type
        $Machine = Get_L2 $br

        # Get Optional Header magic
        Goto $fs ($PeOffset + 24)
        $OptMagic = Get_L2 $br
        if ($OptMagic -ne 0x10B -and $OptMagic -ne 0x20B) {
            throw "Unsupported Optional Header"
        }

        # Get Subsystem version
        Goto $fs ($PeOffset + 24 + 48)
        $MajorSubsystemVersion = Get_L2 $br
        $MinorSubsystemVersion = Get_L2 $br
        $SubsystemVersion = [version]::new($MajorSubsystemVersion, $MinorSubsystemVersion)

        # Get Subsystem
        Goto $fs ($PeOffset + 24 + 68)
        $Subsystem = Get_L2 $br
        
        # Output the result
        [PSCustomObject]@{
            FilePath = $FilePath
            Machine = $MachineMap[$Machine]
            Subsystem = $SubsystemMap[$Subsystem]
            SubsystemVersion = $SubsystemVersion
        }
    }
    catch {
        Write-Error "Error processing file '$FilePath': $($_.Exception.Message)"
    }
    finally {
        # Always close the streams
        if ($br) { $br.Dispose() }
        if ($fs) { $fs.Dispose() }
    }
}
