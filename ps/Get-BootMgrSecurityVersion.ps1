# Generated by Google AI

function Get-BootMgrSecurityVersionBytes {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string]$Path
    )

    # Define Windows API functions using P/Invoke
    if (-not ([PSObject].Assembly.GetType("ResourceHelper"))) {
        Add-Type -TypeDefinition @'
            using System;
            using System.Runtime.InteropServices;
            using System.Text;

            public class ResourceHelper {
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, uint dwFlags);
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern IntPtr FindResource(IntPtr hModule, string lpName, uint lpType);
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern IntPtr LockResource(IntPtr hResData);
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern uint SizeofResource(IntPtr hModule, IntPtr hResInfo);
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern bool FreeLibrary(IntPtr hModule);

                // Constants
                public const uint LOAD_LIBRARY_AS_DATAFILE = 0x00000002;
                public const uint RT_RCDATA = 10;
            }
'@
    }

    $resourceName = "BOOTMGRSECURITYVERSIONNUMBER"

    if (-not (Test-Path $Path -PathType Leaf)) {
        Write-Error "File not found at specified path: $Path"
        return $null
    }

    $hModule = [ResourceHelper]::LoadLibraryEx($Path, [IntPtr]::Zero, [ResourceHelper]::LOAD_LIBRARY_AS_DATAFILE)
    if ($hModule -eq [IntPtr]::Zero) {
        Write-Error "Failed to load the file as a data file. Win32 Error: $('0x{0:X}' -f [System.Runtime.InteropServices.Marshal]::GetLastWin32Error())"
        return $null
    }

    try {
        $hResInfo = [ResourceHelper]::FindResource($hModule, $resourceName, [ResourceHelper]::RT_RCDATA)
        if ($hResInfo -eq [IntPtr]::Zero) {
            Write-Error "Resource '$resourceName' not found in the file."
            return $null
        }

        $hResData = [ResourceHelper]::LoadResource($hModule, $hResInfo)
        $pResourceBytes = [ResourceHelper]::LockResource($hResData)
        $resourceSize = [ResourceHelper]::SizeofResource($hModule, $hResInfo)

        if ($pResourceBytes -eq [IntPtr]::Zero -or $resourceSize -eq 0) {
            Write-Error "Failed to load or lock resource data."
            return $null
        }

        # Copy the raw bytes without conversion or trimming
        $bytes = New-Object byte[] $resourceSize
        [System.Runtime.InteropServices.Marshal]::Copy($pResourceBytes, $bytes, 0, $resourceSize)
        
        # Return the raw byte array
        return $bytes

    } finally {
        if ($hModule -ne [IntPtr]::Zero) {
            [ResourceHelper]::FreeLibrary($hModule) | Out-Null
        }
    }
}
